// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

//! # Message Format
//!
//! A [`Message`] is a piece of user-visible text that typically has
//! variable elements.
//!
//! Often, when writing your application, you need to customize the
//! output based on various variable values:
//!
//! ```text
//! Your search had no results.
//! Your search had one result.
//! Your search had 3 results.
//! ```
//!
//! You don't want to have specific code for each message output to
//! build up the text, and ideally, you'll be supporting localization
//! so that your application can be used by people who speak other
//! languages, which often have different rules concerning pluralization,
//! gender and list formatting.
//!
//! Using the [ICU Message Format] syntax supported by this library, the
//! above text would be generated by this message (in English):
//!
//! ```text
//! {count, plural,
//!   =0 {Your search had no results.}
//!   =1 {Your search had one result.}
//!   other {Your search had # results.}}
//! ```
//!
//! Assuming you had that parsed into a message `search_results`, the code
//! to format that might look like:
//!
//! ```
//! # #[macro_use]
//! # extern crate message_format;
//! # fn main () {
//! # let ctx = message_format::Context::default();
//! # let search_results = &message_format::icu::parse("...").unwrap();
//! # let results: Vec<&str> = vec![];
//! let s = format_message!(ctx, search_results, count => results.len());
//! # }
//! ```
//!
//! Other languages with different rules for plurals, gender and other
//! things can have correct output just by updating the message text without
//! having to modify the code.
//!
//! Separating messages from the code has other benefits as well apart
//! from making localization easier. You may need different branding of
//! your product for different builds, or you may want to be able to have
//! someone edit and proofread the text without having to have them modify
//! the code itself.
//!
//! This module currently provides support for messages using the
//! [ICU Message Format]. In the future, we will support the [Fluent]
//! message format as well.
//!
//! ## Installation
//!
//! This crate works with Cargo and is on
//! [crates.io](https://crates.io/crates/message-format).
//! Add it to your `Cargo.toml` like so:
//!
//! ```toml
//! [dependencies]
//! message-format = "0.0.1"
//! ```
//!
//! This library depends upon some macros being used, so at the top of your crate,
//! you will want to make sure that macros from this crate are used:
//!
//! ```
//! #[macro_use]
//! extern crate message_format;
//! # fn main() {}
//! ```
//!
//! ## Contexts
//!
//! The context stores information that is shared between all of the formats
//! that are formatted using that context. (You might want to have multiple
//! contexts, or you might not.)
//!
//! For now, this stores the locale that is being used, but in the future,
//! it will be used for additional features.
//!
//! ## ICU Formatted Messages
//!
//! The simplest way to create an ICU formatted [`Message`] from code is
//! to [`parse`] it from a text format:
//!
//! ```
//! use message_format::icu;
//!
//! let m = icu::parse("Connecting to {host}...").unwrap();
//! ```
//!
//! For details on the [ICU Message Format] syntax, see the [`icu` module].
//!
//! ## Fluent Formatted Messages
//!
//! Support for the [Fluent] localization format is under development.
//!
//! ## Formatting a Message
//!
//! Messages need arguments or parameters. Since messages typically have named
//! arguments, we can't just pass arguments directly like we might do with
//! `format!` or other lower level formatting operations. Instead, we have
//! our own macros.
//!
//! Arguments can be specified as `name => value` or, if you have a variable
//! with the same name as the argument already, then as just `name`.
//!
//! ```
//! #[macro_use]
//! extern crate message_format;
//!
//! fn main() {
//!     let ctx = message_format::Context::default();
//!     let m1 = message_format::icu::parse("Connecting to {host}...").unwrap();
//!     assert_eq!(format_message!(ctx, &m1, host => "localhost"),
//!                "Connecting to localhost...");
//!
//!     let m2 = message_format::icu::parse("{name} went to {place}.").unwrap();
//!     let name = "Jacob";
//!     assert_eq!(format_message!(ctx, &m2, name, place => "the store"),
//!                "Jacob went to the store.");
//! }
//! ```
//!
//! ## Future Directions
//!
//! In the future, we want to extend this library to support a number of
//! additional features:
//!
//! * Serializing and deserializing messages in a binary format to avoid
//!   needing to parse them on every application startup.
//! * Integration with `rust-locale` or other libraries for doing locale
//!   specific formatting.
//! * Extending the types of data that can be used with [`Value`].
//! * Supporting [Fluent] and perhaps other message format syntaxes. (This
//!   will probably require API changes.)
//! * Offline utilities for compiling and validating message format
//!   strings, converting to and from various formats like XLIFF, etc.
//!
//! ## Contributions
//!
//! Contributions are welcome.
//!
//! [ICU Message Format]: icu/index.html
//! [`icu` module]: icu/index.html
//! [Fluent]: http://projectfluent.org/
//! [`parse`]: icu/fn.parse.html
//! [`Message`]: struct.Message.html
//! [`Value`]: enum.Value.html

#![warn(missing_docs)]
#![deny(trivial_numeric_casts, unsafe_code, unstable_features, unused_import_braces,
        unused_qualifications)]

extern crate language_tags;
#[macro_use]
extern crate nom;

mod args;
mod context;
mod message;
mod message_part;
mod plural_category;
mod plural_classifiers;
mod value;

pub use self::args::{arg, Args};
pub use self::context::Context;
pub use self::message::Message;
pub use self::message_part::MessagePart;
pub use self::plural_category::PluralCategory;
pub use self::plural_classifiers::*;
pub use self::value::Value;

#[macro_export]
macro_rules! format_message {
    ($ctx:expr, $msg:expr) => {
        $ctx.format($msg, None)
    };
    ($ctx:expr, $msg:expr, $($rest:tt)*) => ({
        use $crate::Value;
        $ctx.format($msg, message_args!($($rest)*))
    });
}

#[macro_export]
macro_rules! write_message {
    ($ctx:expr, $msg:expr, $stream:expr) => {
        $ctx.write($msg, $stream, None)
    };
    ($ctx:expr, $msg:expr, $stream:expr, $($rest:tt)*) => ({
        use $crate::Value;
        $ctx.write($msg, $stream, message_args!($($rest)*))
    });
}

#[macro_export]
macro_rules! message_args_aux {
    ($prev:expr, $name:ident => $value:expr) => {
        Some(&$crate::Args {
            name: stringify!($name),
            value: Value::from($value),
            prev: $prev,
        })
    };
    ($prev:expr, $name:ident) => {
        Some(&$crate::Args {
            name: stringify!($name),
            value: Value::from($name),
            prev: $prev,
        })
    };
    ($prev:expr, $name:ident, $($rest:tt)*) => {
        message_args_aux!(
            Some(&$crate::Args {
                name: stringify!($name),
                value: Value::from($name),
                prev: $prev,
            }),
            $($rest)*)
    };
    ($prev:expr, $name:ident => $value:expr, $($rest:tt)*) => {
        message_args_aux!(
            Some(&$crate::Args {
                name: stringify!($name),
                value: Value::from($value),
                prev: $prev,
            }),
            $($rest)*)
    };
}

#[macro_export]
macro_rules! message_args {
    () => { None };
    ($name:ident => $value:expr) => {
        Some(&$crate::Args {
            name: stringify!($name),
            value: Value::from($value),
            prev: None,
        })
    };
    ($name:ident) => {
        Some(&$crate::Args {
            name: stringify!($name),
            value: Value::from($name),
            prev: None,
        })
    };
    ($name:ident, $($rest:tt)*) => {
        message_args_aux!(
            Some(&$crate::Args {
                name: stringify!($name),
                value: Value::from($name),
                prev: None,
            }),
            $($rest)*)
    };
    ($name:ident => $value:expr, $($rest:tt)*) => {
        message_args_aux!(
            Some(&$crate::Args {
                name: stringify!($name),
                value: Value::from($value),
                prev: None,
            }),
            $($rest)*)
    };
}

#[cfg(test)]
mod tests {
    use super::{icu, Context};

    #[test]
    fn format_without_args() {
        let ctx = Context::default();

        let m = icu::parse("Hello!").unwrap();
        let s = format_message!(ctx, &m);
        assert_eq!(s, "Hello!");
    }

    #[test]
    fn format_single_arg() {
        let ctx = Context::default();

        let m = icu::parse("{name}").unwrap();
        let name = "John";
        let s = format_message!(ctx, &m, name);
        assert_eq!(s, "John");
    }

    #[test]
    fn format_single_named_arg() {
        let ctx = Context::default();

        let m = icu::parse("{name}").unwrap();
        let s = format_message!(ctx, &m, name => "John");
        assert_eq!(s, "John");
    }

    #[test]
    fn format_two_args() {
        let ctx = Context::default();

        let m = icu::parse("{a}{b}").unwrap();
        let b = "2";
        let s = format_message!(ctx, &m, a => "1", b);
        assert_eq!(s, "12");
    }

    #[test]
    fn format_three_args() {
        let ctx = Context::default();

        let m = icu::parse("{a}{c}{b}").unwrap();
        let s = format_message!(ctx, &m, a => "1", b => "2", c => "3");
        assert_eq!(s, "132");
    }

    #[test]
    fn write_without_args() {
        let ctx = Context::default();

        let m = icu::parse("Hello!").unwrap();
        let mut stream = String::new();
        write_message!(ctx, &m, &mut stream).unwrap();
        assert_eq!(stream, "Hello!");
    }

    #[test]
    fn write_single_arg() {
        let ctx = Context::default();

        let m = icu::parse("{name}").unwrap();
        let mut stream = String::new();
        write_message!(ctx, &m, &mut stream, name => "John").unwrap();
        assert_eq!(stream, "John");
    }
}

pub mod fluent;
pub mod icu;
